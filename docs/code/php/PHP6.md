# 函数高级



> 目标：在函数基本应用的基础上，了解函数一些较复杂的使用方式

* 作用域
* 静态变量
* 强制类型
* 可变参数
* 可变函数
* 匿名函数

## 1、作用域



> 目标：了解PHP作用域的概念，掌握作用域的限制和破解关系

* **作用域**：即作用范围，指变量能够被访问的范围

* 局部作用域
  * 局部变量
* 全局作用域
  * 全局变量
* 超全局作用域
  * 超全局变量
* 跨域访问



### 1.1、局部作用域（局部变量）



> 概念

**局部作用域**：某个函数内部（函数体）的作用域

* 局部变量：在函数内部定义的变量（形参）
* 局部变量只能在当前函数内部被访问
* 形参只能在局部作用域使用



> 示例

1、局部作用域定义局部变量

```php
#局部作用域
function display(){
    #函数的{}内部属于局部作用域，这里定义的变量属于局部变量
    $a = 100;
    echo $a;
}

display();		#输出100
echo $a;		#报错：未定义变量
```



2、形参属于局部作用域

```php
function display($a = 1){
    echo $a;
}

display();		#输出1
echo $a;		#报错：未定义变量
```



> 小结

1、局部作用域就是函数内部

2、局部作用域里定义的变量是局部变量

3、局部变量只能在对应的局部作用域访问，其他地方不可访问

* 函数外部
* 其他函数内部

4、形参只能在局部作用域中使用（属于局部变量）

5、扩展：形参引用传值，本质是外部变量与局部变量指向同一个内存地址，在外部访问的是外部变量



### 1.2、全局作用域（全局变量）



> 概念

**全局作用域**：即未在其他结构（函数）内部定义的作用域

* 全局变量：在全局作用域定义的变量
* 全局变量只能在全局作用域访问
* 全局变量可以当做实参使用（全局变量传值给局部变量）



> 示例

1、全局变量

```php
#默认属于全局作用域
$a = 100;		#全局变量
```



2、全局变量只能在全局作用域访问

```php
$a = 100;

function display(){
    echo $a;
}

display();		#报错：未定义的变量
```



3、全局变量可以当做实参传递给函数内部使用

```php
$a = 100;

function display($a){	#$a是函数内部的局部变量
    echo $a;
}

display($a);			#100，当前是在全局作用域使用		
```



> 小结

1、全局作用域是在函数的外部作用域

2、全局变量是在全局作用域定义的变量

3、全局变量不能在局部作用域访问

4、全局变量能够在全局作用域下传入给函数的局部变量



### 1.3、超全局作用域（超全局变量）



> 概念

**超全局作用域**：即脚本中任意位置

* 超全局变量：系统定义的预定义变量
* 超全局变量不受作用域限制，都可以访问
* 全局变量都会被收纳在$GLOBALS中
* 可以利用超全局变量来保存数据，让数据不受作用域限制



> 示例

1、超全局变量$GLOBALS

```php
#定义全局变量
$a = 100;

function display(){
    var_dump($GLOBALS);
    echo $GLOBALS['a'];		#输出100
}

display();		#打印很多，包括$a = 100
```



2、将局部变量保存到$GLOBALS中，也可以任意访问

```php
function display(){
    #添加超全局作用域数据
    $GLOBALS['a'] = 100;
}

#必须先运行函数：执行内部代码才有效
display();
echo $GLOBALS['a'];		#输出100
```



> 小结

1、超全局作用域是PHP脚本任意位置

2、超全局变量是系统定义，开发者一般只用来访问数据（不建议通过超全局变量来让变量跨域）

3、$GLOBALS会自动包含全局变量，同时还有以下超全局变量

* $_GET：自动接收GET提交的数据
* $_POST：自动接收POST提交的数据
* $_COOKIE：自动接收cookie数据
* $_FILES：自动接收文件上传的数据
* $GLOBALS（自己包含自己）



### 1.4、跨作用域访问



> 目标：了解PHP中有实现跨域访问的机制，在必要时知道如何实现跨作用域访问



> 概念

跨作用域访问：即在局部作用域访问全局变量，或者在全局作用域访问局部变量

* 在函数内部使用global关键字声明变量
  * 在函数内部声明一个局部变量
    * 如果当前声明的变量名在全局空间存在：系统直接引用
  * 在函数外部声明一个全局变量
  * 两个变量指向同一个内存
  * global声明变量时，不能赋值



> 步骤

1、定义函数在函数内部使用global声明变量

* 函数外存在同名全局变量：内部创建一个同名局部变量
* 函数外不存在同名变量：内部创建一个局部变量，外部创建一个同名全局变量

2、访问修改

* 外部有：可以直接访问
* 外部没有：内部可以直接给值

3、函数运行结束

* 内部局部变量消失
* 外部全局变量存在



> 示例

1、局部访问全局变量

```php
#定义全局变量
$a = 100;

function display(){
    #声明变量：引入全局
    global $a;			#必须同名
    
    echo $a++;
}

display();				#输出100（说明内部访问到全局变量）
echo $a;				#输出101（说明内部修改影响到外部）
```



2、局部声明全局变量，全局作用域访问

```php
function display(){
    #声明全局变量
    global $b;	
    
    $b = 10;
}

echo $b;		#报错：提示未定义变量
display();
echo $b;		#输出10（说明局部变量也是一个全局变量）
```



> 小结

1、global是局部作用域声明全局变量的关键字

* global只能声明，不能赋值
* global声明逻辑
  * 全局变量存在：内部创建一个同名局部变量，并执行外部全局变量
  * 全局变量不存在：内部创建一个局部变量，外部创建一个同名全局变量，并指向同一个内存地址

2、跨作用域访问比较少用，一般要跨作用域访问的都是访问预定义变量

3、作用域划分的目的

* 方便开发者更好的管理数据
* 为了保证数据的安全（同名变量在不同作用域互不干扰）



## 2、静态变量



> 目标：了解静态变量的作用，掌握静态变量的应用



> 概念

**静态变量**：在函数内部定义的，可以在函数多次调用时共用的局部变量

* 静态变量使用static关键字修饰
* 静态变量是在函数内部定义的局部变量
* 静态变量在函数加载（编译）时初始化（只初始化一次）
* 静态变量可以在同一个函数多次调用时共享数据的变化



> 步骤

1、确定函数内的局部变量是否需要在函数多次调用时共享

* 不需要：普通局部变量即可
* 需要：使用static修饰成静态变量

2、在函数内部对静态变量进行运算



> 示例

当函数被调用时输出函数是第几次调用

```php
function display(){
    #普通局部变量：每次调用函数都会执行初始化
    $count1 = 1;
    
    #静态变量：函数加载时初始化被执行（调用时不执行）
    static $count2 = 1;
    
    #参与其他运算的代码都是在调用时执行
    echo $count1++,$count2++;
    
}

display();		#输出1,1
display();		#输出1,2
```



> 流程图解析

![流程图解析](/img/php/函数加载到内存.png)

> 小结

1、静态变量是在函数内部定义的使用static修饰的局部变量

* static修饰的变量是在函数编译（加载）时被初始化
* static修饰的变量行在函数调用时会跳过执行
* 静态变量是保存在函数里面：所以每次调用时修改的值都可以被下次调用使用

2、静态变量的作用

* 让函数在多次调用时能够共享内部数据变化
* 普通局部变量每次调用都会初始化

3、静态变量的使用场景

* 数据需要函数多次调用共享数据
* 在函数使用递归存储数据的时候



## 3、强制类型



> 目标：了解PHP可以利用强类型来规范函数的输入（参数）和输出（返回值），了解强类型的作用

* 强类型参数
* 强类型返回值



### 3.1、强类型参数



> 概念

**强类型参数**：在定义函数时给形参设定类型

* 类型规范是PHP的8种类型
* 强类型的作用
  * 实参必须是形参规定类型
  * 保护函数内部运行逻辑正确
  * 省去函数内部判定逻辑
  * 提升解析效率
* 强类型语法

```php
function 函数名(类型 变量名){}
```



> 示例

```php
#不限定类型
function add1($a,$b){
    return $a + $b;
}

echo add1('1','b1');	#输出1（自动转换）

#强类型限定
function add2(float $a,float $b){
    return $a + $b;
}

echo add2('1','b1');	#报错：实参数据类型不正确
```



> 小结

1、强类型是在形参定义时指定数据类型

* 规定实参必须传入相应类型：否则报错（致命错误）
* 保护函数内部结构运行正确
* 节省开发时间，不需要在内部进行逻辑判定
* 可以提升PHP的解析效率（不用转换）

2、强类型的选择

* PHP是弱类型语言，会自动转换类型，一般可以不用
* 不想在内部进行过多逻辑判定，可以使用强类型参数



### 3.2、强类型返回值



> 概念

**强类型返回值**：指在函数定义时就规定好函数的返回值类型

* 强类型是PHP的8种类型
* 强类型规定后，函数内部的返回值必须是指定类型
* 想让强类型完全生效，需要提前声明
  * declare(strict_types = 1)
* 强类型返回值语法

```php
function 函数名()：返回值类型{}
```



> 示例

```php
#判定数据是否是整形
function is_my_int($n):bool{
    if(is_integer($n)){
        return TRUE;
    }else{
        return 'no';
    }
}

is_my_int(3.1);		#报错：返回值类型必须是布尔类型，返回了一个字符串
```



> 小结

1、强类型返回值是在定义函数时规定

* 规定返回值类型
* 在函数内部使用返回值时必须对应返回值类型

2、强类型返回值的作用

* 保证数据的规范性（对外提供规范数据）

3、想让强类型返回值生效，依赖强类型开启

* 在脚本前面添加：declare(strict_types = 1)



## 4、可变参数



> 目标：了解可变参数的使用方式和作用



> 概念

**可变参数**：PHP提供了一种对于参数不固定的处理方式

* PHP在5.6以后提供了一种主动获取多余的实参的方式
* 可以使用`...`符号实现数组数据的拆分



> 步骤

1、在定义形参过程中，主动提供获取不固定数量实参的形参 `...$args`（变量名随意）

2、在调用函数时传入的多出的实参会被$args接收

3、在函数内部可以使用$args访问多出的实参数据



> 示例

1、求两个（可以多）数的所有数之和

```php
#1、定义函数：对于多余的形参使用...$args保存
function my_sum($a,$b,...$args){
    #2、$args会接收多出的参数（$a和$b为固定参数）
    #3、在函数内部可以使用$args访问多出的实参
    $sum = $a + $b;
    foreach($args as $v){
        $sum += $v;
    }
    
    return $sum;
}

echo my_sum(1,2);		#输出3
echo my_sum(1,2,3,4,5);	#输出15
```



2、将实参数组拆分解构成多个数据

```php
function my_sub($a,$b){
    return $a - $b;
}

$arr = [10,4];
echo my_sub(...$arr);	#输出6
```



> 小结

1、可变参数是指参数的数量可以不确定数量

* 形参中可以定义可变参数，吸收多余的实参变成数组
* 实参专递数据时可以利用可变参数，将数据解构成多个参数

2、可变参数通常用作不确定的数据的计算（数量）



## 5、可变函数



> 目标：了解可变函数的意义，掌握可变函数的使用



> 概念

**可变函数**：即一个变量所保存的值刚好是另外一个函数的名字，那么可以通过变量直接访问函数

* 变量的值是一个函数名（字符串）
* 变量 + `()` 就可以当做函数名访问函数



> 步骤

1、定义一个函数

2、声明一个变量并赋值，值刚好是函数名

3、变量 + `()` 访问函数



> 示例

1、简单实用

```php
function display(){
    echo __FUNCTION__;
}

$var = 'display';		#变量名为一个函数的名字

#可变函数访问
$var();					#输出display
#$var + () == display + () == display()
```



2、实际运用：通常我们是将自定义的函数作为系统函数或者其他位置的回调函数（callback）使用

```php
#取得一个数的绝对值
function jdz($n){
    return $n < 0 ? -$n : $n;
}

#求两个数的绝对值的和
function sum_jdz($a,$b,$func){
    #利用外部的$func函数（回调函数）来实现$a和$b的绝对值求和
    return $func($a) + $func($b);
}

echo sum_jdz(-1,-1,'jdz');	#输出2
```



> 流程图分析

以sum_jdz(-1,-1,'jdz')执行为例

![函数执行流程图](/img/php/函数执行.png)

> 小结

1、可变函数就是利用变量 + `()` 来寻找匹配的函数名当做函数访问

2、可变函数执行逻辑

* 变量取得值（字符串）
* 变量 + `()`：系统自动理解为函数
* 系统寻找变量值对应的函数名
* 调用函数访问



## 6、匿名函数



> 目标：了解匿名函数，掌握匿名函数的使用

* 简单匿名函数
* 回调匿名函数
* 匿名函数闭包



### 6.1、简单匿名函数



> 概念

**匿名函数**：即没有名字的函数

* 定义函数时函数没有名字
* 使用变量保存函数的内存地址
* 通过变量访问函数

* 匿名函数语法

```php
变量 = function(){
    函数体
    return 返回值
};					#注意：本质是给变量赋值，所以需要语句结束符
```



> 示例

```php
#定义匿名函数
$func = function($str){
    echo $str;
};						#注意分号

#调用
$func('hello world');	#输出hello world
```



> 小结

1、匿名函数就是函数定义时没有名字

2、简单匿名函数就是通过变量指向无名函数

3、匿名函数是通过变量来进行访问

4、一般情况下匿名函数比较少这么用



### 6.2、回调匿名函数



> 概念

**回调匿名函数**：指直接将匿名函数定义在函数的实参中，当做一个实参传递给形参



> 示例

1、自定义求一个数组所有元素的立方

```php
$num = [1,2,3];

#求数组立方的函数：需要一个回调函数专门求一个数的立方
function my_cube($arr,$cube){
    $list = [];
    foreach($arr as $value){
        $list[] = $cube($value);
    }
    
    return $list;
}

#调用
$res = my_cube($num,function($n){ return $n ** 3;});
print_r($res);		#array(0=>1,1=>8,2=>27)
```



2、使用系统函数array_map

array_map是一个系统函数，目标是对传入的数组的每一个元素进行相应加工，至于加工成什么就看回调函数了

```php
$arr = [1,2,3];

$arr = array_map(function($n){return $n ** 3;},$arr);
print_r($arr);		#array(0=>1,1=>8,2=>27)
```



> 小结

1、回调匿名函数就是在当函数调用时需要回调函数时，定义一个匿名函数作为实参

2、回调匿名函数的本质也是在定义一个函数，让变量（形参）进行保存并调用

3、回调匿名函数的作用：匿名函数用后即焚，可以释放掉占用的内存



### 6.3、匿名函数闭包



> 概念

**闭包**：闭包（closure）是一个定义在函数内，能够读取其他函数内部变量的函数（闭包函数）

* 函数定义在某个函数内部（内部函数）
* 内部函数是匿名函数
* 内部函数访问外部函数的局部变量
  * 不能直接访问
  * 访问使用use



> 示例

1、简单闭包函数

```php
function outer(){
    $inner = function(){
        echo 'hello world';
    };
    $inner();
}

outer();			#输出hello world
```



2、闭包函数访问内部变量

```php
#错误示例
function outer($str){
    $inner = function(){
        echo $str;
    };
    $inner();
}
outer('hello world');#报错：提示未定义变量$str
```

原理：

* outer是一个函数，$str是outer的一个形参，也就是局部变量，只能在函数内部访问
* \$inner也是一个函数，函数内部只能访问局部变量，而​\$str对于匿名函数$inner来说是外部的，所以不可访问



```php
#正确示例
function outer($str){
    $inner = function() use ($str){
        echo $str;
    };
    $inner();
}
outer('hello world');#输出hello world
```



3、闭包函数可以返回给外部函数调用出，这样可以使得闭包所占用的外部函数资源不会被释放

```php
#正确示例
function outer($str){
    $inner = function($s) use ($str){
        echo $str . $s;
    };
    return $inner;
}
$res = outer('hello');
$res('world');			#输出helloworld
```

原理：

* 函数outer调用结束，本要释放所有内存
* outer返回了一个内部闭包函数的引用，所以函数不会释放到该函数
* \$inner内部闭包函数引用了一个外部函数的局部变量，所以outer也不能释放$str
* \$res('world')找到函数执行，并且应用了之前函数的局部变量$str，所以组合输出hello world



> 小结

1、匿名闭包函数是在函数内部定义的匿名函数

2、虽然闭包函数在函数内部，但是也不能直接访问外部函数的局部变量，需要使用use来引用外部函数变量

3、闭包函数一旦引用了外部函数的局部变量，那么外部函数执行完之后，被引用的局部变量也不会被释放

4、闭包函数可以被返回给外部函数调用出，然后在其他时候直接调用内部闭包函数